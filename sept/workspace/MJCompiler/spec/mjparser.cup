package rs.ac.bg.etf.pp1;

import java.util.ArrayList;
import java.util.HashMap;

import java_cup.runtime.*;
import org.apache.log4j.*;


import rs.etf.pp1.symboltable.Tab;

import rs.etf.pp1.symboltable.concepts.*;

parser code {:

    Logger log = Logger.getLogger(getClass());
	
	Struct boolType;
    
   public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
		System.err.println(msg.toString());
 //       log.error(msg.toString());
    }
    
    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }
:}

scan with{:

Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s; //prsretanje svakog tokena 


:}

init with {: 
   Tab.init(); //Universe opseg
   boolType = new Struct(Struct.None);
   Tab.currentScope().addToLocals(new Obj(Obj.Type, "bool" , boolType));
:}

action code {:

boolean inFor = false; 
boolean extendClass = false; 
boolean fieldsStatic = false;
Struct currentType = null;
Obj currentMethod = null; 

:}


terminal PROG, LBRACE, RBRACE, LPAREN, RPAREN, LSQUARE, RSQUARE, SEMI, CONST, STATIC, COMMA, EXTENDS, CLASS, DOT;
terminal String IDENT ; 
terminal READ, PRINT, BREAK, CONTINUE, OR, AND, IF, FOR, RETURN, INC, DEC, VOID, ELSE, DIFERENT;
terminal PLUS, PLUSEQUAL, MINUSEQUAL, DIVEQUAL, MULEQUAL, MODEQUAL, EQUAL, MINUS;
terminal CONDITIONALEQUAL, LESSEQUAL, MOREEQUAL, LESS, MORE, DIFFERENT;
terminal NUMBER, CHARACTER, BOOL, NEW;
terminal MUL, DIV, MOD;

non terminal ProgDeclList,MethodDeclList, Program, ClassVarDeclPart, SingleClassVarDecl, ClassVarDeclList, ClassDecl;
non terminal ClassDeclMethod, MethodDecl, FormArgs, FormPars, FormalParamDecl, VarArgs,  VarDeclList, VarDecl, StatementList, Statement;
non terminal VarDeclPart, SingleVarDecl, DesignatorStatement, Condition, Matched, Unmatched, ForPart, OptCondition;
non terminal ActualPars, ConstDeclPart, SingleConstDecl, ClassVarDecl, ActualParamList, CondTerm, CondFact, ConstDecl;
non terminal Relop, AssignOp, OptDesignatorStatement, Addop, Mulop, MulopLeft, MulopRight, AddopLeft, AddopRight;
non terminal Integer ConstValue;
non terminal Obj ProgName, Designator, ClassIdent;
non terminal Struct RetType, Expr, Term, ExprFactorType, Factor, ExtType, Type;
non terminal Boolean OptStatic;

Program ::= PROG ProgName:p ProgDeclList LBRACE MethodDeclList RBRACE
			{:
			Tab.chainLocalSymbols(p);
			Tab.closeScope();
			:}
			;

ProgName ::= IDENT:pName
{:
  RESULT = Tab.insert(Obj.Prog, pName, Tab.noType); //vraca Obj koji je u tabeli simbola
  Tab.openScope();
:}
; 

Type ::= IDENT:typeName
		 {:
		 Obj typeNode = Tab.find(typeName);
		 if( typeNode == Tab.noObj){
		 parser.report_error("Nije pronadjen tip" + typeName + "u tabeli simbola", null);
		 }
		 else {
		 if( Obj.Type == typeNode.getKind()) 
		 currentType = RESULT = typeNode.getType();
		 else { 
		 parser.report_error("Greska na liniji" + typeNameleft+ ": Ime " + typeName + " ne predstavlja tip ", null);
		 currentType = RESULT = Tab.noType;
		 }
		 }
		 :}
		 ;

ConstDecl ::= CONST Type:t ConstDeclPart SEMI
			  {:
			  if(!t.equals(Tab.intType) && !t.equals(Tab.charType) && !t.equals(parser.boolType)) {
			  parser.report_info("Greska na liniji:"+ tleft + " tip terminala nije ni numConst ni charConst ni boolConst", null);
			  }
			  :};

ConstDeclPart ::= ConstDeclPart COMMA SingleConstDecl
					|
					SingleConstDecl
					;

SingleConstDecl ::= IDENT EQUAL ConstValue;

ConstValue ::= NUMBER 
			   |
			   CHARACTER
			   |
			   BOOL
			   ;
			   
ClassVarDeclList ::= ClassVarDeclList ClassVarDecl
					 |
					 /*epsilon*/
					 ;
			   
ClassVarDecl ::= OptStatic:b {: if (b) fieldsStatic = true; :} Type ClassVarDeclPart SEMI
				  {: fieldsStatic = false ; :} 
				  ;

ClassVarDeclPart ::= ClassVarDeclPart SingleClassVarDecl
					 |
					 SingleClassVarDecl
					 ;
SingleClassVarDecl ::= IDENT:varName
					   {:
					   parser.report_info("Deklarisano polje klase "+ varName+" na liniji "+ varNameleft, null);
					   Obj sym = Tab.currentScope().findSymbol(varName);
					   if( sym == null ){ 
					   Tab.insert( Obj.Fld, varName, currentType);
					   }
					   else {
					   parser.report_info("Greska na liniji, ime nije jedinstveno: "+ varNameleft, null);
					   }
					   :}
                       |
					   IDENT:varName LSQUARE RSQUARE
					   {:
					   parser.report_info("Deklarisano polje klase "+ varName+" na liniji "+ varNameleft, null);
					   Obj sym = Tab.currentScope().findSymbol(varName);
					   if( sym == null ){ 
	                   Tab.insert( Obj.Fld, varName, new Struct(Struct.Array, currentType));
					   }
					   else {
					   parser.report_info("Greska na liniji, ime nije jedinstveno: "+ varNameleft, null);
					   }
					   :}
					   ;
					 
					 
OptStatic ::= STATIC 
			  |
			  ;
			  
ExtType ::= EXTENDS Type:t
			{:
			if ( t.getKind() != Struct.Class ) 
			parser.report_error("Semanticka greska na liniji " +tleft +": Ime "+t+" nije unutrasnja klasa glavnog programa", null);
			extendClass = true;
			RESULT = t;
			:}
			|
			/*epsilon*/
			;
			  
ClassDecl	::= CLASS IDENT ExtType LBRACE ClassVarDeclList ClassDeclMethod RBRACE;

ClassDeclMethod ::= LBRACE MethodDeclList RBRACE
					|
					;


MethodDeclList ::= MethodDeclList MethodDecl
				   |
				   /*epsilon*/
				   ;
				   
RetType ::= Type 
			|
			VOID
			;
				   
MethodDecl ::= OptStatic:b RetType:retType IDENT:methName
			   {:
			   currentMethod = Tab.insert(Obj.Meth, methName, retType);
			   Tab.openScope();
			   parser.report_info("Obradjuje se funkcija " + methName + " na liniji " + methNameleft, null);
			   :}
			   LPAREN FormArgs RPAREN VarDeclList LBRACE StatementList RBRACE
			   {:
			   Tab.chainLocalSymbols(currentMethod);
			   Tab.closeScope();
			   :};

VarDeclList ::= VarDeclList VarDecl 
                |
				;
				
VarDecl ::= Type VarDeclPart SEMI;

VarDeclPart ::= VarDeclPart COMMA SingleVarDecl 
				|
				SingleVarDecl
				;
				
SingleVarDecl ::= IDENT:varName
				 {:
				  parser.report_info("Deklarisana promenljiva "+ varName+" na liniji "+ varNameleft, null);
				 
				  Obj sym = Tab.currentScope().findSymbol(varName);
				  if( sym == null) 
			      Tab.insert(Obj.Var, varName, currentType);
				  else {
				  parser.report_info("Greska na liniji, nije jedinstveno ime "+  varNameleft, null);
				  }
			      :}
				  |
				  IDENT:varName LSQUARE RSQUARE
				  {:
				  parser.report_info("Deklarisan niz "+ varName+" na liniji "+ varNameleft, null);
				  
				  Obj sym = Tab.currentScope().findSymbol(varName);
				  if( sym == null ) 
				  Tab.insert(Obj.Var, varName, new Struct(Struct.Array, currentType));
				  else {
				  parser.report_info("Greska na liniji, nije jedinstveno ime "+  varNameleft, null);
				  }
				  :}
				  ;


FormArgs ::= FormPars COMMA VarArgs
			 |
			 FormPars
			 |
			 VarArgs
			 |
			 /*epsilon*/
			 ;
	

VarArgs ::= Type DOT DOT DOT IDENT;	
			 
			 

FormPars ::= FormPars COMMA FormalParamDecl
					|
					FormalParamDecl
					;				   
					
StatementList ::= StatementList Statement
				  |
				  ;
				  
Statement ::= Matched | Unmatched; 

OptDesignatorStatement ::= DesignatorStatement | ;

ForPart ::= FOR LPAREN OptDesignatorStatement SEMI OptCondition SEMI OptDesignatorStatement RPAREN
			{: inFor = true; :} ; 

OptCondition ::= Condition | ;

Unmatched ::= IF LPAREN Condition RPAREN Statement
				|
				IF LPAREN Condition RPAREN Matched ELSE Unmatched
				|
				ForPart
				Unmatched
				;

Matched ::= DesignatorStatement SEMI
			|
			IF LPAREN Condition RPAREN Matched ELSE Matched
			|
			ForPart Matched
			|
			BREAK SEMI 
			|
			CONTINUE SEMI
			| 
			RETURN Expr SEMI
			|
            RETURN SEMI
			|
			READ LPAREN Designator RPAREN SEMI 
			| 
			PRINT LPAREN Expr RBRACE SEMI 
			|
			LBRACE StatementList RBRACE 
			; 
			
DesignatorStatement ::= Designator:d AssignOp Expr:e
						{:
						if (!( d.getKind() == Obj.Var || d.getKind() == Obj.Fld || d.getKind() == Obj.Elem ))
						    parser.report_error("Greska na liniji " + dleft+" : Designator nije varijabla, element niza ili polje unutar objekta", null);
						else if ( !( e.assignableTo(d.getType()) ) )
							 parser.report_error("Greska na liniji " + dleft + " : " + " nekompatibilni tipovi u dodeli vrednosti ", null);
						else {
						
						}
						:}
						|
						Designator LPAREN ActualPars RPAREN
						|
						Designator:d INC 
						{:
						if (!( d.getKind() == Obj.Var || d.getKind() == Obj.Fld || d.getKind() == Obj.Elem )) 
						   if ( d.getType() != Tab.intType )
						   parser.report_error("Greska na liniji " + dleft+" : Designator nije varijabla, element niza ili polje klase, pa ne moze biti inkrementiran.", null);
						else {
						parser.report_error("Greska na liniji " + dleft+" : Designator nije varijabla, element niza ili polje klase, pa ne moze biti inkrementiran.", null);
						}
						:}
						|
						Designator:d DEC
						{:
						if (!( d.getKind() == Obj.Var || d.getKind() == Obj.Fld || d.getKind() == Obj.Elem ))
						  if( d.getType() != Tab.intType ) 
						   parser.report_error("Greska na liniji " + dleft+" : Designator nije tipa int, pa ne moze biti dekrementiran.", null);  
						else { 		
						parser.report_error("Greska na liniji " + dleft+" : Designator nije varijabla, element niza ili polje klase, pa ne moze biti dekrementiran.", null);
						}	
						:}	
						;
						
ActualPars ::= ActualParamList 
			   |
			   /*epsilon*/
			   ;
			   
ActualParamList ::= ActualParamList COMMA Expr
					|
					Expr
					;
					
					
Condition ::= Condition OR CondTerm
			  |
			  CondTerm
			  ;
			  
CondTerm ::= CondTerm AND CondFact
			 |
			 CondFact
			 ;
			 
CondFact ::= Expr Relop Expr
			|
			Expr
			;
			
Expr ::= ExprFactorType; 

ExprFactorType ::= ExprFactorType:t1 Addop Term:t2
				   {:
				   if (t1.equals(t2) && t1 == Tab.intType) 
				      RESULT = t1;
				   else{
				   parser.report_error("Greska na liniji "+ t1left+" : nekompatibilni tipovi u izrazu za sabiranje.", null);
				   RESULT = Tab.noType;
				   }
				   :}
				   |
				   Term:t 
				   {:
				   RESULT = t;
				   :}
				   |
				   MINUS Term
				   ;

Term ::= Term:t1 Mulop Factor:t2
		 |
		 Factor:t
		 {:
		 RESULT = t;
		 :}  
		 ;
			
Factor ::= Designator 
		   |
		   Designator:func LPAREN ActualPars RPAREN
		   {:
		   if(func.getKind() == Obj.Meth) 
		      parser.report_info("Pronadjen poziv funkcije " + func.getName() + " na liniji " + funcleft, null);
			else{
			parser.report_error("Greska na liniji " + funcleft+" : ime " + func.getName() + " nije funkcija!", null);
			}
		   :}
		   |
		   NUMBER
		   |
		   CHARACTER
		   |
		   BOOL
		   |
		   NEW Type
		   |
		   NEW Type LSQUARE Expr RSQUARE
		   |
		   LPAREN Expr RPAREN
		   ;
		   
Designator ::= IDENT:name
				{:
					Obj obj = Tab.find(name);
					if (obj == Tab.noObj) { 
						parser.report_error("Greska na liniji " + nameleft+ " : ime "+name+" nije deklarisano! ", null);
					}
					RESULT = obj;
				:}
			   |
			   IDENT DOT IDENT
			   |
			   IDENT LSQUARE Expr RSQUARE
			   ;
			   
AssignOp ::= EQUAL
			 |
			 AddopRight
			 |
			 MulopRight
			 ;
			
Relop ::= CONDITIONALEQUAL
		  |
		  DIFFERENT 
		  |
		  LESS
		  |
		  MOREEQUAL
		  |
		  MORE
		  |
		  LESSEQUAL
		  |
		  DIFERENT
		  ;
		  
Addop ::= AddopLeft | AddopRight;

AddopLeft ::= PLUS
			  |
			  MINUS
			  ;
			  
AddopRight ::= PLUSEQUAL 
			   |
			   MINUSEQUAL ;	

Mulop ::= MulopLeft 
		  |
		  MulopRight
		  ;
		  
MulopLeft ::= MUL
			  |
			  DIV
			  |
			  MOD
			  ;
			  
MulopRight ::= MULEQUAL
			   |
			   DIVEQUAL
			   |
			   MODEQUAL
			   ;
			   
			   
			  
		   