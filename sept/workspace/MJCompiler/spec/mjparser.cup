package rs.ac.bg.etf.pp1;

import java.util.ArrayList;
import java.util.HashMap;

import java_cup.runtime.*;
import org.apache.log4j.*;


// import java.io.*;
import rs.etf.pp1.symboltable.Tab;
import rs.etf.pp1.symboltable.concepts.*;
import rs.etf.pp1.symboltable.structure.*;
import rs.etf.pp1.mj.runtime.Code;

parser code {:

    int globProm = 0;
    int lokProm = 0;
    int globKon = 0;
    
    int pozivFunkUMain = 0;
    int globIStaticFunc = 0;
    int deklFormArg = 0;

    boolean errorDetected = false;

    Logger log = Logger.getLogger(getClass());
	
	Struct boolType;
    
   public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
        errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
		System.err.println(msg.toString());
 //       log.error(msg.toString());
    }
    
    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }
:}

scan with{:

Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s; //prsretanje svakog tokena 


:}

init with {: 
   Tab.init(); //Universe opseg
   boolType = new Struct(Struct.None);
   Tab.currentScope().addToLocals(new Obj(Obj.Type, "bool" , boolType));
:}

action code {:

boolean rightOp = false;
boolean inFor = false; 
boolean isVoid = false;
boolean extendClass = false; 
boolean fieldsStatic = false;
boolean returnFound = false;
Struct currentType = null;
Obj currentMethod = null; 
Obj currentClass = null;
ArrayList<Struct> actualParams = new ArrayList();

boolean checkMethodParams(Obj func,int line){
  HashMap<Integer, Struct> formPars = new HashMap<Integer, Struct>();
  Struct varArgsType = null;
  for ( Obj locVar: func.getLocalSymbols()) {
      if(locVar.getFpPos() > 0 ) {
	    if (locVar.getLocalSymbols().isEmpty())
	    { formPars.put(locVar.getFpPos(), locVar.getType()); } 
	    else 
	    varArgsType = locVar.getType().getElemType();
	  }
	  
	  int varArgsLength = 0;
	  if ( varArgsType == null && formPars.size() != actualParams.size() ) {
	  parser.report_info("Greska: ne poklapa se broj stvarnih i formalnih argumenata ", null); 
	  }
	  else
	  {
	  if ( actualParams.size() < formPars.size() ) {
	  parser.report_info("Greska: ne poklapa se broj stvarnih i formalnih argumenata ", null);
	  }
	  else if ( actualParams.size() > formPars.size() ){
	  varArgsLength = actualParams.size() - formPars.size();
	  if ( varArgsLength > 0 ) {
	  Obj varArgsArray = Tab.insert( Obj.Var, "varArgsArray", new Struct(Struct.Array, varArgsType));
	  }
	  }
	  }
	  
  }
  actualParams.clear();
  return true;
} 

class FactorType {
   private Obj designator;
   private Struct type;
   
   public FactorType(Obj d, Struct t){
   designator = d;
   type = t; }
   
   public Obj getDesignator(){
   return designator; }
   
   public void setDesignator(Obj d) {
   designator = d; }
   
   public Struct getType() {
   return type; }
   
   public void setType(Struct t){
   type = t; }
}

:}


terminal PROG, LBRACE, RBRACE, LPAREN, RPAREN, LSQUARE, RSQUARE, SEMI, CONST, STATIC, COMMA, EXTENDS, CLASS, DOT;
terminal String IDENT ; 
terminal READ, PRINT, BREAK, CONTINUE, OR, AND, IF, FOR, RETURN, INC, DEC, VOID, ELSE, DIFERENT;
terminal PLUS, PLUSEQUAL, MINUSEQUAL, DIVEQUAL, MULEQUAL, MODEQUAL, EQUAL, MINUS;
terminal CONDITIONALEQUAL, LESSEQUAL, MOREEQUAL, LESS, MORE, DIFFERENT;
terminal NUMBER, CHARACTER, BOOL, NEW;
terminal MUL, DIV, MOD;

non terminal ProgDeclList,MethodDeclList, Program, ClassVarDeclPart, SingleClassVarDecl, ClassVarDeclList, ClassDecl;
non terminal ClassDeclMethod, MethodDecl, FormArgs, FormPars, FormalParamDecl, VarArgs,  VarDeclList, VarDecl, StatementList, Statement;
non terminal VarDeclPart, SingleVarDecl, DesignatorStatement, Condition, Matched, Unmatched, ForPart, OptCondition;
non terminal ActualPars, ConstDeclPart, SingleConstDecl, ClassVarDecl, ActualParamList, CondTerm, CondFact, ConstDecl;
non terminal AssignOp, OptDesignatorStatement, Addop, MulopLeft, MulopRight, AddopLeft, AddopRight;
non terminal Integer Relop, Mulop;
non terminal Integer ConstValue;
non terminal Obj ProgName, Designator, ClassIdent;
non terminal FactorType ExprFactorType, Factor, Term;
non terminal Struct RetType, Expr, ExtType, Type;
non terminal Boolean OptStatic;

Program ::= PROG ProgName:p ProgDeclList LBRACE MethodDeclList RBRACE
			{:
			Tab.chainLocalSymbols(p);
			Tab.closeScope();
			:}
			;

ProgName ::= IDENT:pName
{:
  RESULT = Tab.insert(Obj.Prog, pName, Tab.noType); //vraca Obj koji je u tabeli simbola
  Tab.openScope();
:}
; 

Type ::= IDENT:typeName
		 {:
		 Obj typeNode = Tab.find(typeName);
		 if( typeNode == Tab.noObj){
		 parser.report_error("Nije pronadjen tip" + typeName + "u tabeli simbola", null);
		 }
		 else {
		 if( Obj.Type == typeNode.getKind()) 
		 currentType = RESULT = typeNode.getType();
		 else { 
		 parser.report_error("Greska na liniji" + typeNameleft+ ": Ime " + typeName + " ne predstavlja tip ", null);
		 currentType = RESULT = Tab.noType;
		 }
		 }
		 :}
		 ;

ConstDecl ::= CONST Type:t ConstDeclPart SEMI
			  {:
			  if(!t.equals(Tab.intType) && !t.equals(Tab.charType) && !t.equals(parser.boolType)) {
			  parser.report_info("Greska na liniji:"+ tleft + " tip terminala nije ni numConst ni charConst ni boolConst", null);
			  }
			  :};

ConstDeclPart ::= ConstDeclPart COMMA SingleConstDecl
					|
					SingleConstDecl
					;

SingleConstDecl ::= IDENT:varName EQUAL ConstValue
					{:
					parser.report_info("Deklarisana konstanta "+ varName+" na liniji "+ varNameleft, null);
					
					Obj sym = Tab.currentScope.findSymbol(varName);
					if ( sym == null ) {
					    Obj result = Tab.insert( Obj.Con, varName, currentType);
					    parser.globKon++;
					}
					else {
					parser.report_info("Greska na liniji, nije jedinstveno ime: "+ varNameleft, null);	
					}
					
					:}
					;

ConstValue ::= NUMBER 
			   |
			   CHARACTER
			   |
			   BOOL
			   ;
			   
ClassVarDeclList ::= ClassVarDeclList ClassVarDecl
					 |
					 /*epsilon*/
					 ;
			   
ClassVarDecl ::= OptStatic:b {: if (b) fieldsStatic = true; :} Type ClassVarDeclPart SEMI
				  {: fieldsStatic = false ; :} 
				  ;

ClassVarDeclPart ::= ClassVarDeclPart COMMA SingleClassVarDecl
					 |
					 SingleClassVarDecl
					 ;
SingleClassVarDecl ::= IDENT:varName
					   {:
					   parser.report_info("Deklarisano polje klase "+ varName+" na liniji "+ varNameleft, null);
					   Obj sym = Tab.currentScope().findSymbol(varName);
					   if( sym == null ){ 
					   Obj field = Tab.insert( Obj.Fld, varName, currentType);
					   if ( fieldsStatic ) field.setFpPos(1);
					   }
					   else {
					   parser.report_info("Greska na liniji, ime nije jedinstveno: "+ varNameleft, null);
					   }
					   :}
                       |
					   IDENT:varName LSQUARE RSQUARE
					   {:
					   parser.report_info("Deklarisano polje klase "+ varName+" na liniji "+ varNameleft, null);
					   Obj sym = Tab.currentScope().findSymbol(varName);
					   if( sym == null ){ 
	                   Obj field = Tab.insert( Obj.Fld, varName, new Struct(Struct.Array, currentType));
					   if ( fieldsStatic ) field.setFpPos(1);
					   }
					   else {
					   parser.report_info("Greska na liniji, ime nije jedinstveno: "+ varNameleft, null);
					   }
					   :}
					   ;
					   
ClassIdent ::= IDENT:name 
			  {:
			  Obj sym = Tab.currentScope().findSymbol(name);
			  if ( sym == null ) 
			  currentClass = RESULT = Tab.insert( Obj.Type, name, new Struct( Struct.Class) );
			  else {
			  parser.report_info("Greska na liniji, nije jedinstveno ime "+ nameleft, null);
			  currentClass = RESULT = new Obj( Obj.Type, name, new Struct( Struct.Class) );
			  }
			  Tab.openScope();
			  :}
			  ;
					 
					 
OptStatic ::= STATIC 
			  |
			  ;
			  
ExtType ::= EXTENDS Type:t
			{:
			if ( t.getKind() != Struct.Class ) 
			parser.report_error("Semanticka greska na liniji " +tleft +": Ime "+t+" nije unutrasnja klasa glavnog programa", null);
			extendClass = true;
			RESULT = t;
			:}
			|
			/*epsilon*/
			;
			  
ClassDecl	::= CLASS ClassIdent:o ExtType LBRACE ClassVarDeclList ClassDeclMethod RBRACE
				{:
				Tab.chainLocalSymbols(o);
				Tab.closeScope();
				currentClass = null;
				:}
				;

ClassDeclMethod ::= LBRACE MethodDeclList RBRACE
					|
					;


MethodDeclList ::= MethodDeclList MethodDecl
				   |
				   /*epsilon*/
				   ;
				   
RetType ::= Type:t
			{:
			RESULT = t;
			:}
			|
			VOID
			{:
			RESULT = Tab.noType;
			isVoid = true;
			:}
			;
				   
MethodDecl ::= OptStatic:b RetType:retType IDENT:methName
			   {:
			   Obj sym = Tab.currentScope().findSymbol(methName);
			   if ( sym == null) 
			   currentMethod = Tab.insert(Obj.Meth, methName, retType);
			   else {
			   parser.report_info("Greska na liniji, nije jedinstveno ime "+ methNameleft, null);
			   currentMethod = new Obj(Obj.Meth, methName, retType);
			   }
			   Tab.openScope();
			   if(b){
			   currentMethod.setFpPos(1);
			   parser.globIStaticFunc++;
			   }
			   if( currentClass == null) 
			   parser.globIStaticFunc++;

			   parser.report_info("Obradjuje se funkcija " + methName + " na liniji " + methNameleft, null);
			   :}
			   LPAREN FormArgs RPAREN VarDeclList LBRACE 
			   {:
			   
			   :}
			   StatementList RBRACE
			   {:
			   if(!returnFound && retType!= Tab.noType)
			   parser.report_error("Semanticka greska na liniji " + methNameleft + ": funcija " + methName + " nema return iskaz!", null);
			   
			   Tab.chainLocalSymbols(currentMethod);
			   Tab.closeScope();
			   
			   currentMethod = null;
			   isVoid = false;
			   returnFound = false;
			   :}
			   ;

VarDeclList ::= VarDeclList VarDecl 
                |
				;
				
VarDecl ::= Type VarDeclPart SEMI;

VarDeclPart ::= VarDeclPart COMMA SingleVarDecl 
				|
				SingleVarDecl
				;
				
SingleVarDecl ::= IDENT:varName
				 {:
				
				  parser.report_info("Deklarisana promenljiva "+ varName+" na liniji "+ varNameleft, null);
				 
				  Obj sym = Tab.currentScope().findSymbol(varName);
				  if( sym == null) 
			      Tab.insert(Obj.Var, varName, currentType);
				  else {
				  parser.report_info("Greska na liniji, nije jedinstveno ime "+  varNameleft, null);
				  }
				  
				    if ( currentMethod == null && currentClass == null )
				    parser.globProm++;  
				    else if ( currentMethod != null && currentClass == null && currentMethod.getName().equals("main"));
				    parser.lokProm++;
				 
				  
			      :}
				  |
				  IDENT:varName LSQUARE RSQUARE
				  {:
				  parser.report_info("Deklarisan niz "+ varName+" na liniji "+ varNameleft, null);
				  
				  Obj sym = Tab.currentScope().findSymbol(varName);
				  if( sym == null ) 
				  Tab.insert(Obj.Var, varName, new Struct(Struct.Array, currentType));
				  else {
				  parser.report_info("Greska na liniji, nije jedinstveno ime "+  varNameleft, null);
				  }
				  
				  if ( currentMethod == null && currentClass == null )
				  parser.globProm++;  
				  else if ( currentMethod != null && currentClass == null && currentMethod.getName().equals("main"));
				  parser.lokProm++;
				     
				  :}
				  ;


FormArgs ::= FormPars COMMA VarArgs
			 |
			 FormPars
			 |
			 VarArgs
			 |
			 /*epsilon*/
			 ;
	

VarArgs ::= Type DOT DOT DOT IDENT:niz
			{:
			Obj obj = Tab.insert( Obj.Var, niz, new Struct( Struct.Array, currentType )) ;
			obj.setFpPos(Tab.currentScope().getnVars());
			HashTableDataStructure locals = new HashTableDataStructure();
			locals.insertKey(Tab.noObj);
			obj.setLocals(locals);
			:}
			;	
			 
			 

FormPars ::= FormPars COMMA FormalParamDecl
					|
					FormalParamDecl
					;		
					
FormalParamDecl ::= Type IDENT:varName
			{:
				parser.report_info("Deklarisana promenljiva "+ varName+" na liniji "+ varNameleft, null);
				   Obj sym = Tab.currentScope().findSymbol(varName);
				     if (sym == null) {
						Obj obj = Tab.insert(Obj.Var, varName, currentType);
						obj.setFpPos(Tab.currentScope().getnVars());
					}
				    else {
						parser.report_info("Greska na liniji, nije jedinstveno ime "+ varNameleft, null);
				    }
				
				parser.deklFormArg++;
			:}
			|
			Type IDENT:varName LSQUARE RSQUARE 
			{:
				parser.report_info("Deklarisan niz "+ varName+" na liniji "+ varNameleft, null);
				Obj sym = Tab.currentScope().findSymbol(varName);
				     if (sym == null) {
						Obj obj = Tab.insert(Obj.Var, varName, new Struct(Struct.Array, currentType));
						obj.setFpPos(Tab.currentScope().getnVars() + 1);
					}
				    else {
						parser.report_info("Greska na liniji, nije jedinstveno ime "+ varNameleft, null);
				    }
				
				parser.deklFormArg++;
			:}
			;
			   
					
StatementList ::= StatementList Statement
				  |
				  ;
				  
Statement ::= Matched | Unmatched; 

OptDesignatorStatement ::= DesignatorStatement | ;

ForPart ::= FOR LPAREN OptDesignatorStatement SEMI OptCondition SEMI OptDesignatorStatement RPAREN
			{: inFor = true; :} ; 

OptCondition ::= Condition | ;

Unmatched ::= IF LPAREN Condition RPAREN Statement
				|
				IF LPAREN Condition RPAREN Matched ELSE Unmatched
				|
				ForPart
				Unmatched
				{: inFor = false; :}
				;

Matched ::= DesignatorStatement SEMI
			|
			IF LPAREN Condition RPAREN Matched ELSE Matched
			|
			ForPart Matched
			{: inFor = false; :}
			|
			BREAK:b SEMI 
			{:
					if (!inFor) {
						parser.report_error("Semanticka greska na liniji " + bleft + ": BREAK se moze koristiti samo unutar FOR petlje", null);
					}
				:}
			|
			CONTINUE:b SEMI
            {:
					if (!inFor) {
						parser.report_error("Semanticka greska na liniji " + bleft + ": BREAK se moze koristiti samo unutar FOR petlje", null);
					}
				:}			
			| 
			RETURN Expr:t SEMI
			{:
			returnFound = true; 
			Struct currMethType = currentMethod.getType();
			if( !currMethType.compatibleWith(t) || isVoid == false && currMethType != Tab.noType )  {
				 	parser.report_error("Greska na liniji " + tleft + " : " + "tip izraza u return naredbi ne slaze se sa tipom povratne vrednosti funkcije " + currentMethod.getName(), null);
				 }			  	 
			
			:}
			|
            RETURN SEMI
			|
			READ LPAREN Designator:d RPAREN SEMI 
			{:
			
			if (currentMethod != null && currentClass == null && currentMethod.getName().equals("main"))
			parser.pozivFunkUMain++;
			
			if ( d.getKind() == Obj.Fld || d.getKind() == Obj.Fld || d.getKind() == Obj.Fld )
			    if ( d.getType() == Tab.intType || d.getType() == Tab.charType || d.getType() == parser.boolType ) 
				{
				}
				else { 
				parser.report_error("Greska na liniji " + dleft + ": designator nije odgovarajuceg tipa.", null);
				}
			:}
			| 
			PRINT LPAREN Expr:e RBRACE SEMI
			{:
			
			if (currentMethod != null && currentClass == null && currentMethod.getName().equals("main"))
			parser.pozivFunkUMain++;
			
			if (!(e.equals(Tab.intType) || e.equals(Tab.charType) || e.equals(parser.boolType)))
			    parser.report_error("Semanticka greska na liniji " + eleft + ": Operand instrukcije PRINT mora biti char ili int tipa", null);
			:}
			|
			LBRACE StatementList RBRACE 
			; 
			
DesignatorStatement ::= Designator:d AssignOp Expr:e
						{:
						if (!( d.getKind() == Obj.Var || d.getKind() == Obj.Fld || d.getKind() == Obj.Elem ))
						    parser.report_error("Greska na liniji " + dleft+" : Designator nije varijabla, element niza ili polje unutar objekta", null);
						else if ( !( e.assignableTo(d.getType()) ) )
							 parser.report_error("Greska na liniji " + dleft + " : " + " nekompatibilni tipovi u dodeli vrednosti ", null);
						else {
						
						}
						:}
						|
						Designator:d LPAREN ActualPars RPAREN
						{:
						
						if (currentMethod != null && currentClass == null && currentMethod.getName().equals("main"))
					    parser.pozivFunkUMain++;
						
						if (d.getKind() == Obj.Meth ) {
						 parser.report_info("Pronadjen poziv funkcije " + d.getName() + " na liniji " + dleft, null);
						 if ( checkMethodParams(d, dleft) ){
						 
						 }
						}
						else {
						 parser.report_error("Greska na liniji " + dleft+" : ime " + d.getName() + " nije funkcija!", null);
						}
						:}
						|
						Designator:d INC 
						{:
						if (!( d.getKind() == Obj.Var || d.getKind() == Obj.Fld || d.getKind() == Obj.Elem )) 
						   if ( d.getType() != Tab.intType )
						   parser.report_error("Greska na liniji " + dleft+" : Designator nije varijabla, element niza ili polje klase, pa ne moze biti inkrementiran.", null);
						else {
						parser.report_error("Greska na liniji " + dleft+" : Designator nije varijabla, element niza ili polje klase, pa ne moze biti inkrementiran.", null);
						}
						:}
						|
						Designator:d DEC
						{:
						if (!( d.getKind() == Obj.Var || d.getKind() == Obj.Fld || d.getKind() == Obj.Elem ))
						  if( d.getType() != Tab.intType ) 
						   parser.report_error("Greska na liniji " + dleft+" : Designator nije tipa int, pa ne moze biti dekrementiran.", null);  
						else { 		
						parser.report_error("Greska na liniji " + dleft+" : Designator nije varijabla, element niza ili polje klase, pa ne moze biti dekrementiran.", null);
						}	
						:}	
						;
						
ActualPars ::= ActualParamList 
			   |
			   /*epsilon*/
			   ;
			   
ActualParamList ::= ActualParamList COMMA Expr:e
					{:
					actualParams.add(e);
					:}
					|
					Expr:e
					{:
					actualParams.add(e);
					:}
					;
					
					
Condition ::= Condition OR CondTerm
			  |
			  CondTerm
			  ;
			  
CondTerm ::= CondTerm AND CondFact
			 |
			 CondFact
			 ;
			 
CondFact ::= Expr:e1 Relop:o Expr:e2
			{:
			if ( !e1.assignableTo(e2) && e1.getKind() != Struct.Array && e1.getElemType().getKind() != Struct.Char) 
			{ 
			parser.report_error("Greska na liniji: "+e1left+": nekompatibilni tipovi", null); 
			}
			else if (e1.getKind() == Struct.Class || e1.getKind() == Struct.Array) {
			if ( o != Code.ne && o != Code.eq) 
			parser.report_error("Semanticka greska na liniji: " + e2left + " : Uz promenljive tipa klase ili niza, od relacionih operatora, mogu se koristiti samo != i ==.", null);
			}
			:}
			|
			Expr
			;
		
Expr ::= ExprFactorType:e
		 {:
		 RESULT = e.getType();
		 :}; 

ExprFactorType ::= ExprFactorType:t1 Addop Term:t2
				   {:
				   if (t1.equals(t2) && t1.getType() == Tab.intType) 
				    if ( rightOp = true && ( t1.getDesignator().getKind() == Obj.Var || t1.getDesignator().getKind() == Obj.Elem || t1.getDesignator().getKind() == Obj.Fld ))
					{
				      RESULT = t1;
					  }
				   else{
				   parser.report_error("Greska na liniji "+ t1left+" : nekompatibilni tipovi u izrazu za sabiranje.", null);
				   RESULT = new FactorType(null, Tab.noType);
				   }
				   :}
				   |
				   Term:t 
				   {:
				   RESULT = t;
				   :}
				   |
				   MINUS Term:t
				   {:
				   if ( t.getType() != Tab.intType ) 
				   parser.report_error("Greska na liniji "+ tleft+" : Term nije tipa int.", null);
				   :}
				   ;

Term ::= Term:t1 Mulop Factor:t2
         {:
		 if( t1.getType() == Tab.intType && t2.getType() == Tab.intType)
		    if ( rightOp = true && ( t1.getDesignator().getKind() == Obj.Var || t1.getDesignator().getKind() == Obj.Elem || t1.getDesignator().getKind() == Obj.Fld ))
			{
			}
			else
		    { parser.report_error("Greska na liniji "+ t1left+" : nekompatibilni tipovi u izrazu za mnozenje.", null); }
		 :}
		 |
		 Factor:t
		 {:
		 RESULT = t;
		 :}  
		 ;
			
Factor ::= Designator 
		   |
		   Designator:func LPAREN ActualPars RPAREN
		   {:
		   if(func.getKind() == Obj.Meth) 
		      parser.report_info("Pronadjen poziv funkcije " + func.getName() + " na liniji " + funcleft, null);
			else{
			parser.report_error("Greska na liniji " + funcleft+" : ime " + func.getName() + " nije funkcija!", null);
			}
		   :}
		   |
		   NUMBER
		   |
		   CHARACTER
		   |
		   BOOL
		   |
		   NEW Type:t
		   {:
		   if ( t.getKind() != Struct.Class ) 
		   { parser.report_error("Greska na liniji " + tleft + " nije u pitanju klasa!", null); }
		   :}
		   |
		   NEW Type LSQUARE Expr:e RSQUARE 
		   {:
		   if ( e != Tab.intType ) 
		   {
		   parser.report_error("Semanticka greska na liniji " + eleft + ": Expr mora biti int tipa", null);
		   }
		   :}
		   |
		   LPAREN Expr RPAREN
		   ;
		   
Designator ::= IDENT:name
				{:
					Obj obj = Tab.find(name);
					if (obj == Tab.noObj) { 
						parser.report_error("Greska na liniji " + nameleft+ " : ime "+name+" nije deklarisano! ", null);
					}
					RESULT = obj;
				:}
			   |
			   Designator:d DOT IDENT:name
			   {:
			   if ( d.getType().getKind() != Struct.Class )
				parser.report_error("Greska na liniji " + nameleft+ " : izraz nije klasnog tipa! ", null);
				
				Obj member = d.getType().getMembersTable().searchKey(name);
				if ( member != null ) {
				 RESULT = member;
				 if ( d.getKind() == Obj.Type && member.getFpPos() == 0 ) 
				 parser.report_error("Greska na liniji " + dleft+ " nije staticka metoda, a pristupa joj se preko imena klase ", null);
				}
				else {
				parser.report_error("Greska na liniji " + nameleft+ " : ime "+name+" nije polje klase! ", null);
				}
			   :}
			   |
			   Designator:d LSQUARE Expr:e RSQUARE
			   {:
			    if ( d.getType().getKind() != Struct.Array )
				parser.report_error("Greska na liniji " + dleft+ " : izraz nije klasnog tipa! ", null);
				if(e == Tab.intType){
				}
				else {
				parser.report_error("Greska na liniji " + eleft+ " : ime "+ e +" nije int! ", null);
				}
			   :}
			   ;
			   
AssignOp ::= EQUAL
			 |
			 AddopRight
			 |
			 MulopRight
			 ;
			
Relop ::= CONDITIONALEQUAL
		  |
		  DIFFERENT 
		  |
		  LESS
		  |
		  MOREEQUAL
		  |
		  MORE
		  |
		  LESSEQUAL
		  |
		  DIFERENT
		  ;
		  
Addop ::= AddopLeft
          |
		  AddopRight
		  {: rightOp = true; :}
		  ;

AddopLeft ::= PLUS
			  |
			  MINUS
			  ;
			  
AddopRight ::= PLUSEQUAL
			   |
			   MINUSEQUAL
				;	

Mulop ::= MulopLeft 
		  |
		  MulopRight
		  {: rightOp = true; :}
		  ;
		  
MulopLeft ::= MUL
			  |
			  DIV
			  |
			  MOD
			  ;
			  
MulopRight ::= MULEQUAL
			   |
			   DIVEQUAL
			   |
			   MODEQUAL
			   ;
			   
			   
			  
		   